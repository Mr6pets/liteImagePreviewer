# 图像编辑

<cite>
**本文档中引用的文件**  
- [editor.js](file://js/editor.js)
- [_crop.scss](file://src/scss/_crop.scss)
- [_watermark.scss](file://src/scss/_watermark.scss)
- [ui.js](file://js/ui.js)
- [eventHandler.js](file://js/eventHandler.js)
- [imageManager.js](file://js/imageManager.js)
- [viewer.js](file://js/viewer.js)
- [core.js](file://js/core.js)
</cite>

## 目录
1. [简介](#简介)
2. [图像滤镜编辑](#图像滤镜编辑)
3. [裁剪功能实现](#裁剪功能实现)
4. [水印功能实现](#水印功能实现)
5. [编辑状态管理](#编辑状态管理)
6. [常见问题排查](#常见问题排查)

## 简介
liteImagePreviewer 提供了完整的图像编辑功能，包括亮度、对比度、饱和度调节，多种滤镜应用，图像裁剪以及文字/图片水印添加。本文档深入剖析 `editor.js` 的核心实现机制，详细说明各项编辑功能的技术细节和交互流程。

**Section sources**
- [editor.js](file://js/editor.js#L1-L50)
- [core.js](file://js/core.js#L1-L29)

## 图像滤镜编辑

### 滤镜参数管理
`ImageEditor` 类通过 `imageFilters` 对象管理当前编辑状态下的滤镜参数，包括亮度、对比度、饱和度和特殊滤镜效果。当进入编辑模式时，系统会保存当前图片的原始滤镜设置，以便在取消编辑时恢复。

```mermaid
flowchart TD
Start([进入编辑模式]) --> SaveOriginal["保存原始滤镜设置"]
SaveOriginal --> UpdateUI["更新滑块UI显示"]
UpdateUI --> ApplyFilter["应用实时滤镜"]
ApplyFilter --> WaitInput["等待用户输入"]
WaitInput --> CheckType{"参数类型?"}
CheckType --> |基础参数| UpdateValue["更新brightness/contrast/saturation"]
CheckType --> |滤镜类型| UpdateFilter["更新filter类型"]
UpdateValue --> ApplyFilter
UpdateFilter --> ApplyFilter
```

**Diagram sources**
- [editor.js](file://js/editor.js#L15-L25)
- [editor.js](file://js/editor.js#L100-L150)

### CSS Filter 动态设置
系统通过 `applyFilters()` 方法动态生成 CSS filter 字符串并应用到预览图像上。该方法根据当前滤镜参数构建 filter 字符串，支持亮度、对比度、饱和度的基础调整，以及灰度、怀旧、反色、模糊等特殊滤镜效果。

```mermaid
flowchart TD
Start([应用滤镜]) --> CheckImage{"预览图像存在?"}
CheckImage --> |否| End
CheckImage --> |是| GetFilters["获取当前滤镜参数"]
GetFilters --> BuildString["构建filter字符串"]
BuildString --> AddBasic["添加基础调整: brightness, contrast, saturate"]
AddBasic --> AddSpecial["添加特殊滤镜: grayscale, sepia, invert, blur"]
AddSpecial --> ApplyStyle["设置viewerImage.style.filter"]
ApplyStyle --> End
```

**Diagram sources**
- [editor.js](file://js/editor.js#L150-L180)
- [ui.js](file://js/ui.js#L100-L120)

### 事件绑定与参数传递
滤镜编辑的事件绑定在 `eventHandler.js` 中完成，通过监听滑块输入事件和滤镜按钮点击事件，调用 `updateFilter()` 方法更新相应参数，并实时应用滤镜效果。

**Section sources**
- [editor.js](file://js/editor.js#L180-L220)
- [eventHandler.js](file://js/eventHandler.js#L100-L120)

## 裁剪功能实现

### 裁剪模式控制
裁剪功能通过 `toggleCropMode()` 方法控制，该方法切换裁剪覆盖层的显示状态，并管理裁剪相关UI元素的显示/隐藏。进入裁剪模式时，系统会初始化裁剪框并添加相应的事件监听器。

```mermaid
flowchart TD
Start([开始裁剪]) --> ToggleMode["toggleCropMode(true)"]
ToggleMode --> InitBox["初始化裁剪框位置和大小"]
InitBox --> AddListeners["添加事件监听器"]
AddListeners --> ShowOverlay["显示裁剪覆盖层"]
ShowOverlay --> WaitAction["等待用户操作"]
WaitAction --> DragBox["拖动裁剪框"]
WaitAction --> ResizeBox["调整裁剪框大小"]
DragBox --> UpdatePosition["更新裁剪框位置"]
ResizeBox --> UpdateSize["更新裁剪框尺寸"]
UpdatePosition --> Constrain["约束在图片边界内"]
UpdateSize --> Constrain
Constrain --> Redraw["重绘UI"]
```

**Diagram sources**
- [editor.js](file://js/editor.js#L220-L260)
- [_crop.scss](file://src/scss/_crop.scss#L1-L50)

### 裁剪框渲染与交互
裁剪框的样式定义在 `_crop.scss` 文件中，使用半透明黑色背景和虚线边框突出显示裁剪区域。系统通过 `initCropBox()` 方法计算裁剪框的初始位置和大小（默认为图片的60%），并考虑图片在容器中的偏移。

```mermaid
classDiagram
class CropBox {
+position : absolute
+border : 2px dashed white
+box-shadow : 0 0 0 9999px rgba(0,0,0,0.5)
+cursor : move
}
class CropHandle {
+position : absolute
+width : 20px
+height : 20px
+background : white
+border-radius : 50%
+border : 2px solid $primary-color
+cursor : nw-resize/ne-resize/sw-resize/se-resize
}
class CropOverlay {
+position : absolute
+top : 0
+left : 0
+width : 100%
+height : 100%
+background : rgba(0,0,0,0.5)
+z-index : 10
}
CropOverlay --> CropBox : "包含"
CropOverlay --> CropHandle : "包含"
CropHandle --> CropBox : "定位在四个角"
```

**Diagram sources**
- [_crop.scss](file://src/scss/_crop.scss#L1-L100)
- [editor.js](file://js/editor.js#L260-L350)

### Canvas 裁剪与更新
`applyCrop()` 方法使用 Canvas API 执行实际的裁剪操作。系统首先计算裁剪区域相对于原始图片的坐标，然后根据缩放比例将裁剪区域绘制到 Canvas 上，最后将 Canvas 转换为 Data URL 并更新图片数据。

```mermaid
sequenceDiagram
participant UI as "用户界面"
participant Editor as "ImageEditor"
participant Canvas as "Canvas API"
participant ImageManager as "ImageManager"
UI->>Editor : 点击"应用裁剪"
Editor->>Editor : 获取裁剪框位置和尺寸
Editor->>Editor : 计算相对坐标和缩放比例
Editor->>Canvas : 创建Canvas元素
Canvas->>Canvas : 设置Canvas尺寸
Canvas->>Canvas : drawImage()执行裁剪绘制
Canvas->>Canvas : toDataURL()转换为图片数据
Canvas->>Editor : 返回裁剪后的图片数据
Editor->>ImageManager : 更新当前图片src
Editor->>UI : 更新预览图和缩略图
Editor->>Editor : 退出裁剪模式
Editor->>Editor : 重置变换
```

**Diagram sources**
- [editor.js](file://js/editor.js#L500-L580)
- [imageManager.js](file://js/imageManager.js#L1-L50)

**Section sources**
- [editor.js](file://js/editor.js#L220-L600)

## 水印功能实现

### 水印层结构
水印功能通过 `toggleWatermarkMode()` 方法控制，水印层的DOM结构包含一个透明的覆盖层和可拖动的水印文本元素。水印文本的初始位置居中，支持用户拖动调整位置。

```mermaid
classDiagram
class WatermarkOverlay {
+position : absolute
+top : 0
+left : 0
+width : 100%
+height : 100%
+z-index : 10
+pointer-events : none
}
class WatermarkText {
+position : absolute
+top : 50%
+left : 50%
+transform : translate(-50%, -50%)
+color : white
+font-size : 30px
+font-weight : bold
+text-shadow : 2px 2px 4px rgba(0,0,0,0.5)
+pointer-events : auto
+cursor : move
+user-select : none
}
class WatermarkControl {
+display : flex
+flex-direction : column
+gap : 10px
+margin-bottom : 15px
}
WatermarkOverlay --> WatermarkText : "包含"
WatermarkOverlay --> WatermarkControl : "包含"
```

**Diagram sources**
- [_watermark.scss](file://src/scss/_watermark.scss#L1-L50)
- [editor.js](file://js/editor.js#L600-L650)

### 位置定位与透明度控制
系统通过 `startWatermarkDrag()`、`watermarkDrag()` 和 `endWatermarkDrag()` 方法实现水印的拖动功能。水印的位置通过 `left` 和 `top` CSS 属性控制，拖动时会移除 `transform` 属性以确保定位准确。

```mermaid
flowchart TD
Start([开始拖动水印]) --> RecordStart["记录起始坐标和当前位置"]
RecordStart --> AddListeners["添加mousemove和mouseup监听器"]
AddListeners --> Move["鼠标移动"]
Move --> CalculateDelta["计算移动距离deltaX, deltaY"]
Move --> UpdatePosition["更新left和top属性"]
Move --> RemoveTransform["移除transform属性"]
UpdatePosition --> Continue["继续监听"]
Continue --> Move
Move --> Release["释放鼠标"]
Release --> CleanUp["清理事件监听器"]
CleanUp --> End
```

**Diagram sources**
- [editor.js](file://js/editor.js#L700-L750)
- [_watermark.scss](file://src/scss/_watermark.scss#L50-L90)

### 叠加渲染逻辑
`applyWatermark()` 方法使用 Canvas API 将水印叠加到原始图片上。系统首先加载原始图片到 Canvas，然后根据缩放比例计算水印在 Canvas 上的坐标，最后使用 Canvas 的绘图上下文绘制水印文本。

```mermaid
sequenceDiagram
participant Editor as "ImageEditor"
participant Canvas as "Canvas API"
participant Image as "Image对象"
participant UI as "用户界面"
Editor->>Image : 创建Image对象并加载原始图片
Image->>Canvas : 图片加载完成
Canvas->>Canvas : 设置Canvas尺寸为原始图片尺寸
Canvas->>Canvas : drawImage()绘制原始图片
Canvas->>Canvas : 计算水印坐标和字体大小
Canvas->>Canvas : 设置绘图样式(color, font, alpha)
Canvas->>Canvas : 根据样式绘制阴影或描边
Canvas->>Canvas : fillText()绘制水印文本
Canvas->>Canvas : toDataURL()转换为带水印的图片数据
Canvas->>Editor : 返回处理后的图片数据
Editor->>ImageManager : 更新当前图片src
Editor->>UI : 更新预览图和缩略图
Editor->>Editor : 退出水印模式
```

**Diagram sources**
- [editor.js](file://js/editor.js#L750-L850)
- [imageManager.js](file://js/imageManager.js#L1-L50)

**Section sources**
- [editor.js](file://js/editor.js#L600-L850)
- [_watermark.scss](file://src/scss/_watermark.scss#L1-L90)

## 编辑状态管理

### 状态保存与撤销
系统通过 `saveOriginalImageData()` 方法在进入编辑模式时保存原始滤镜设置，在用户取消编辑时通过 `cancelImageChanges()` 方法恢复这些设置。应用更改时，当前滤镜参数会被保存到图片数据中。

```mermaid
flowchart TD
Start([编辑流程]) --> EnterEdit["进入编辑模式"]
EnterEdit --> SaveOriginal["保存原始滤镜设置到originalImageData"]
SaveOriginal --> Modify["修改滤镜参数"]
Modify --> CheckAction{"用户选择?"}
CheckAction --> |应用| ApplyChanges["applyImageChanges()"]
CheckAction --> |取消| CancelChanges["cancelImageChanges()"]
ApplyChanges --> SaveToImage["将当前滤镜保存到图片数据"]
ApplyChanges --> ClosePanel["关闭编辑面板"]
CancelChanges --> RestoreOriginal["从originalImageData恢复原始设置"]
CancelChanges --> ClosePanel
RestoreOriginal --> ApplyFilters["应用恢复的滤镜"]
ApplyFilters --> ClosePanel
```

**Diagram sources**
- [editor.js](file://js/editor.js#L80-L100)
- [editor.js](file://js/editor.js#L190-L220)

### 事件绑定流程
所有编辑相关的事件绑定都在 `eventHandler.js` 中完成，通过 `bindEvents()` 方法集中管理。系统监听滑块输入、按钮点击、键盘快捷键等事件，调用相应的编辑方法。

**Section sources**
- [editor.js](file://js/editor.js#L190-L220)
- [eventHandler.js](file://js/eventHandler.js#L100-L150)

## 常见问题排查

### 裁剪失真问题
裁剪失真通常是由于缩放比例计算不准确导致的。系统通过 `naturalWidth/naturalHeight` 与显示尺寸的比例来计算正确的缩放因子，确保裁剪后的图片保持原始质量。

**解决方案**:
1. 确保使用 `img.naturalWidth` 和 `imgRect.width` 计算水平缩放比例
2. 确保使用 `img.naturalHeight` 和 `imgRect.height` 计算垂直缩放比例
3. 在 `drawImage()` 时应用正确的缩放比例

**Section sources**
- [editor.js](file://js/editor.js#L540-L560)

### 水印偏移问题
水印偏移通常是由于坐标转换错误导致的。系统在应用水印时会根据原始图片与显示图片的缩放比例转换坐标，确保水印位置准确。

**解决方案**:
1. 使用 `getBoundingClientRect()` 获取显示尺寸
2. 使用 `naturalWidth/naturalHeight` 获取原始尺寸
3. 计算缩放比例 `scaleX = naturalWidth / displayWidth`
4. 将显示坐标乘以缩放比例得到Canvas坐标

**Section sources**
- [editor.js](file://js/editor.js#L780-L800)